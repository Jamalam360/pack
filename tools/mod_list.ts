// Walks the root directory for *.pw.toml files, and uses the Modrinth API
// to get their primary category.
import { findPackwizFiles } from "./packwiz_utils.ts";
import { log } from "./utils.ts";

type CategoryListing = Record<string, string[]>;

// Overrides of mods that are not on Modrinth, since I am not dealing with
// the Curseforge API docs.
const OVERRIDES: CategoryListing = {};

export async function walkAndFindCategories(): Promise<CategoryListing> {
  if (!Deno.cwd().endsWith("pack")) {
    throw new Error("Expected CWD to be `pack`");
  }

  const pwFiles = (await findPackwizFiles(Deno.cwd()));
  const categories: CategoryListing = {};

  for (const toml of pwFiles) {
    let category: string | string[] | null = null;

    if (toml.update?.modrinth?.["mod-id"]) {
      log(
        "Request",
        `Getting Modrinth info for ${toml.name} (${
          toml.update.modrinth["mod-id"]
        })`,
      );
      const res = await fetch(
        `https://api.modrinth.com/v2/project/${toml.update.modrinth["mod-id"]}`,
        {
          headers: {
            "User-Agent":
              "Jamalam's Modpack Category Finder (james<at>jamalam.tech, jamalam#0001)",
          },
        },
      ).then((r) => r.json());
      category = res["categories"];
    } else {
      for (const override of Object.entries(OVERRIDES)) {
        if (override[1].includes(toml.name)) {
          category = override[0];
        }
      }
    }

    if (category == null) {
      log("Error", `Couldn't find category for mod ${toml.name}`);
      categories["Unknown"] = categories["Unknown"] || [];
      categories["Unknown"].push(toml.name);
    } else {
      if (Array.isArray(category)) {
        for (const cat of category) {
          categories[cat] = categories[cat] || [];
          categories[cat].push(toml.name);
        }
      } else {
        categories[category] = categories[category] || [];

        categories[category] = [toml.name];
      }
    }
  }

  return categories;
}

if (Deno.args.includes("--update-mod-list")) {
  const categories = await walkAndFindCategories();
  const sortedCategories = Object.entries(categories).sort((a, b) =>
    a[0].localeCompare(b[0])
  );
  log("Info", "Updating MODS.md");

  const content = `
# Mods

This file is autogenerated by \`tools/get_categories.ts\`.

There are ${sortedCategories.length} mod categories with ${
    new Set(...Object.entries(categories).map((v) => v[1])).size
  } mods in the modpack.

Some mods are included in multiple categories.

${
    sortedCategories.map((v) =>
      `## ${v[0][0].toUpperCase() + v[0].slice(1)})

${v[1].map((v) => `- ${v}`).join("\n")}
`
    ).join("\n")
  }
  `.trim() + "\n";

  await Deno.writeTextFile("MODS.md", content);
  log("Info", "Done!");
}
